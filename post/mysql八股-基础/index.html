<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Lynn's Site"><meta property="og:type" content="article"><meta property="og:image" content="/img/ram.png"><meta property="twitter:image" content="/img/ram.png"><meta name=title content="【八股】mysql-基础"><meta property="og:title" content="【八股】mysql-基础"><meta property="twitter:title" content="【八股】mysql-基础"><meta name=description content="李柞霖，武汉大学硕士研究生, 开源爱好者 | 这里是 李柞霖 的个人主页"><meta property="og:description" content="李柞霖，武汉大学硕士研究生, 开源爱好者 | 这里是 李柞霖 的个人主页"><meta property="twitter:description" content="李柞霖，武汉大学硕士研究生, 开源爱好者 | 这里是 李柞霖 的个人主页"><meta property="twitter:card" content="summary"><meta name=keyword content="李柞霖, Li Zuolin, Lynn Lee, 李柞霖的主页"><link rel="shortcut icon" href=/image/favicon.ico><title>【八股】mysql-基础 | 李柞霖的博客</title><link rel=canonical href=/post/mysql%E5%85%AB%E8%82%A1-%E5%9F%BA%E7%A1%80/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link href=https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css rel=stylesheet type=text/css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>Lynn's Site</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/research>research</a></li><li><a href=/categories/technology>technology</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/ram.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/mysql%E5%85%AB%E8%82%A1 title=mysql八股>mysql八股</a></div><h1>【八股】mysql-基础</h1><h2 class=subheading></h2><span class=meta>Posted by
Lynn
on
Friday, May 12, 2023</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=什么是非关系型数据库>什么是非关系型数据库？</h1><p>非关系型数据库也叫NOSQL，采用键值对的形式进行存储。</p><p>它的读写性能很高，易于扩展，可分为内存性数据库以及文档型数据库，比如 Redis，Mongodb，HBase等等。</p><p>适合使用非关系型数据库的场景：</p><ul><li>日志系统</li><li>地理位置存储</li><li>数据量巨大</li><li>高可用</li></ul><h1 id=关系型和非关系型数据库的区别>关系型和非关系型数据库的区别</h1><ul><li>关系型数据库的优点<ul><li>容易理解。因为它采用了关系模型来组织数据。</li><li>可以保持数据的一致性。</li><li>数据更新的开销比较小。</li><li>支持复杂查询（带where子句的查询）</li></ul></li><li>非关系型数据库的优点<ul><li>不需要经过SQL层的解析，读写效率高。</li><li>基于键值对，数据的扩展性很好。</li><li>可以支持多种类型数据的存储，如图片，文档等等。</li></ul></li></ul><h1 id=mysql-支持哪些存储引擎>MySQL 支持哪些存储引擎?</h1><p>MySQL 支持多种存储引擎,比如 InnoDB,MyISAM,Memory,Archive 等等.在大多数的情况下,直接选择使用 InnoDB 引擎都是最合适的,InnoDB 也是 MySQL 的默认存储引擎。</p><h2 id=myisam-和-innodb-的区别有哪些>MyISAM 和 InnoDB 的区别有哪些：</h2><ul><li>InnoDB 支持事务，MyISAM 不支持</li><li>InnoDB 支持外键，而 MyISAM 不支持</li><li>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</li><li>Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；</li><li>InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。</li><li>MyISAM 采用表级锁(table-level locking)；InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li></ul><h1 id=数据库三范式>数据库三范式</h1><ul><li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li><li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。</li><li>第三范式：任何非主属性不依赖于其它非主属性。</li></ul><h1 id=超键候选键主键外键分别是什么>超键、候选键、主键、外键分别是什么</h1><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h1 id=sql约束种类>SQL约束种类</h1><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h1 id=varchar和char的区别>varchar和char的区别</h1><p>char 是一个定长字段,假如申请了<code>char(10)</code>的空间,那么无论实际存储多少内容.该字段都占用 10 个字符,而 varchar 是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.</p><p>在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用 char,否则应该尽量使用 varchar.例如存储用户 MD5 加密后的密码,则应该使用 char。</p><h1 id=mysql中in和exists的区别>MySQL中in和exists的区别</h1><p>MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><p>如果查询的两个表大小相当，那么用in和exists差别不大。 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</p><p>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p><h1 id=dropdelete与truncate的区别>drop、delete与truncate的区别</h1><h2 id=回答1>回答1</h2><p>Drop、Delete、Truncate都表示删除，但是三者有一些差别：</p><p><strong>Delete</strong>用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。</p><p><strong>Truncate</strong>删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比delete更快，占用的空间更小。</p><p><strong>Drop</strong>命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。</p><p>因此，在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有数据的时候用Truncate。</p><h2 id=回答2>回答2</h2><ul><li>Drop直接删掉表;</li><li>Truncate删除表中数据，再插入时自增长id又从1开始 ;</li><li>Delete删除表中数据，可以加where字句。</li></ul><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/image-20210822203927822.png alt=image-20210822203927822></p><h2 id=具体解析>具体解析</h2><ol><li>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</li><li>表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</li><li>一般而言，drop > truncate > delete</li><li>应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</li><li>TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</li><li>truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</li><li>delete语句为DML（Data Manipulation Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 trigger，执行的时候将被触发。</li><li>truncate、drop是DDL（Data Define Language),操作立即生效，原数据不放到 rollback segment中，不能回滚</li><li>在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果与事务无关，用truncate即可实现。如果和事务有关，或老是想触发trigger,还是用delete。</li><li>Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</li><li>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</li><li>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器</li></ol><h1 id=存储过程>存储过程</h1><p>存储过程是一些预编译的 SQL 语句。</p><p>1、更加直白的理解：存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p><p>2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</p><p>但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java 开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好。</p><h1 id=mysql-执行流程是怎样的>MySQL 执行流程是怎样的？</h1><p><img src="https://github.com/lynnlee1229/PictureBed/blob/main/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png?raw=true" alt=img></p><p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong></p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。</li></ul><h2 id=连接器>连接器</h2><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><h2 id=查询缓存>查询缓存</h2><p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。</p><h2 id=解析sql>解析SQL</h2><p>解析器会做如下两件事情。</p><p>第一件事情，<strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p><p>第二件事情，<strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><h2 id=执行sql>执行SQL</h2><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是预处理阶段；</li><li>optimize 阶段，也就是优化阶段；</li><li>execute 阶段，也就是执行阶段</li></ul><h3 id=预处理>预处理</h3><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li></ul><h3 id=优化>优化</h3><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，比如下图的 key 为 <code>PRIMARY</code> 就是使用了主键索引。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png alt=img></p><h3 id=执行>执行</h3><h4 id=主键索引查询>主键索引查询</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>select</span> <span style=color:#ff79c6>*</span> <span style=color:#ff79c6>from</span> product <span style=color:#ff79c6>where</span> id <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span></code></pre></div><p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 <strong>const</strong> 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 <strong>read_first_record</strong> 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li></ul><p>至此，这个语句就执行完成了</p><h4 id=全表扫描>全表扫描</h4><p>举个全表扫描的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>select * from product where name = &#39;iphone&#39;;
</span></span></code></pre></div><p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 <strong>ALL</strong> 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li><li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li></ul><h4 id=索引下推>索引下推</h4><p>索引下推是MySQL 5.6 推出的查询优化策略，能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p><p>举一个具体的例子，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E8%B7%AF%E9%A3%9E%E8%A1%A8.png alt=img></p><p>现在有下面这条查询语句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>select</span> <span style=color:#ff79c6>*</span> <span style=color:#ff79c6>from</span> t_user  <span style=color:#ff79c6>where</span> age <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>20</span> <span style=color:#ff79c6>and</span> reward <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>100000</span>;
</span></span></code></pre></div><p>联合索引当遇到范围查询 (>、&lt;) 就会停止匹配，也就是 <strong>age 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。</p><p>那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；</li><li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</li><li>Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；</li><li>接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。</p><p>而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；</li><li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给 Server 层。</li><li>Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward = 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。</p><p>当你发现执行计划里的 Extr 部分显示了 <strong>“Using index condition”</strong>，说明使用了索引下推。</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b/%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92.png alt=img></p><h1 id=mysql一行记录是怎样存储的>MYSQL一行记录是怎样存储的</h1><h2 id=数据存放在哪个文件>数据存放在哪个文件</h2><p>先来看看 MySQL 数据库的文件存放在哪个目录？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>mysql<span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>SHOW</span> VARIABLES <span style=color:#ff79c6>LIKE</span> <span style=color:#f1fa8c>&#39;datadir&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>+</span><span style=color:#6272a4>---------------+--------------------------+
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>|</span> Variable_name <span style=color:#ff79c6>|</span> Value                    <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>+</span><span style=color:#6272a4>---------------+--------------------------+
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>|</span> datadir       <span style=color:#ff79c6>|</span> <span style=color:#ff79c6>/</span>opt<span style=color:#ff79c6>/</span>homebrew<span style=color:#ff79c6>/</span>var<span style=color:#ff79c6>/</span>mysql<span style=color:#ff79c6>/</span> <span style=color:#ff79c6>|</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>+</span><span style=color:#6272a4>---------------+--------------------------+
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#bd93f9>1</span> <span style=color:#ff79c6>row</span> <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>set</span> (<span style=color:#bd93f9>0</span>.<span style=color:#bd93f9>01</span> sec)
</span></span></code></pre></div><p>我们每创建一个 database（数据库） 都会在 /opt/homebrew/var/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。</p><p>比如，我这里有一个名为 test 的 database，该 database 里有一张名为 t数据库表。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/image-20230516101906814.png alt=image-20230516101906814></p><p>然后，我们进入/opt/homebrew/var/mysql/test目录，看看里面有什么文件？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#ff79c6>(</span>base<span style=color:#ff79c6>)</span> lynnlee@LynndeMacBook-Pro mysql % ls /opt/homebrew/var/mysql/test
</span></span><span style=display:flex><span>orderitems.ibd		t.ibd			user_profile.ibd
</span></span></code></pre></div><p>可以看到，共有三个文件，这三个文件分别代表着【<strong>MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中】</strong></p><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li></ul><p>好了，现在我们知道了一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件</p><h2 id=表空间文件的结构是怎么样的>表空间文件的结构是怎么样的</h2><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png alt=img></p><p>下面我们从下往上一个个看看。</p><p>1、行（row）</p><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><p>后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。</p><p>2、页（page）</p><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p><p><strong>页是 InnoDB 存储引擎磁盘管理的最小单元</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的</p><p>总之知道表中的记录存储在「数据页」里面就行。</p><p>3、extent（区）</p><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。</p><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。</p><p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p><p>那具体怎么解决呢？</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了</strong>。</p><p>4、segment（段）</p><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合</li></ul><p>好了，终于说完表空间的结构了。接下来，就具体讲一下 InnoDB 的行格式了。</p><h2 id=innodb行格式>InnoDB行格式</h2><p>行格式（row_format），就是一条记录的存储结构。</p><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p><ul><li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li><li>由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</li><li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。</li></ul><p>Redundant 行格式我这里就不讲了，因为现在基本没人用了，这次重点介绍 Compact 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/COMPACT.drawio-20230516103517498.png alt=img></p><p>可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。</p><p>接下里，分别详细说下。</p><p><strong>记录的额外信息</strong></p><p>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。</p><ol><li>变长字段长度列表</li></ol><p>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p><p>所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p><p>为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>TABLE</span> <span style=color:#ff79c6>`</span>t_user<span style=color:#ff79c6>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>`</span>id<span style=color:#ff79c6>`</span> <span style=color:#8be9fd;font-style:italic>int</span>(<span style=color:#bd93f9>11</span>) <span style=color:#ff79c6>NOT</span> <span style=color:#ff79c6>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>`</span>name<span style=color:#ff79c6>`</span> <span style=color:#8be9fd;font-style:italic>VARCHAR</span>(<span style=color:#bd93f9>20</span>) <span style=color:#ff79c6>DEFAULT</span> <span style=color:#ff79c6>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>`</span>phone<span style=color:#ff79c6>`</span> <span style=color:#8be9fd;font-style:italic>VARCHAR</span>(<span style=color:#bd93f9>20</span>) <span style=color:#ff79c6>DEFAULT</span> <span style=color:#ff79c6>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>`</span>age<span style=color:#ff79c6>`</span> <span style=color:#8be9fd;font-style:italic>int</span>(<span style=color:#bd93f9>11</span>) <span style=color:#ff79c6>DEFAULT</span> <span style=color:#ff79c6>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>PRIMARY</span> <span style=color:#ff79c6>KEY</span> (<span style=color:#ff79c6>`</span>id<span style=color:#ff79c6>`</span>) <span style=color:#ff79c6>USING</span> BTREE
</span></span><span style=display:flex><span>) ENGINE <span style=color:#ff79c6>=</span> InnoDB <span style=color:#ff79c6>DEFAULT</span> <span style=color:#8be9fd;font-style:italic>CHARACTER</span> <span style=color:#ff79c6>SET</span> <span style=color:#ff79c6>=</span> ascii ROW_FORMAT <span style=color:#ff79c6>=</span> COMPACT;
</span></span></code></pre></div><p>现在 t_user 表里有这三条记录：</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/t_test.png alt=img></p><p>接下来，我们看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的。</p><p>先来看第一条记录：</p><ul><li>name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；</li><li>phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；</li><li>age 列和 id 列不是变长字段，所以这里不用管。</li></ul><p>这些变长字段的真实数据占用的字节数会按照列的顺序<strong>逆序存放</strong>（等下会说为什么要这么设计），所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%e5%8f%98%e9%95%bf%e5%ad%97%e6%ae%b5%e9%95%bf%e5%ba%a6%e5%88%97%e8%a1%a81.png alt=img></p><p><strong>第三条记录</strong>中 phone 列的值是 NULL，<strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A83.png alt=img></p><blockquote><p>为什么「变长字段长度列表」的信息要按照逆序存放？</p></blockquote><p>这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p><p>同样的道理， NULL 值列表的信息也需要逆序存放。</p><p>如果你不知道什么是 CPU Cache，可以看<a href=https://xiaolincoding.com/os/1_hardware/how_to_make_cpu_run_faster.html>这篇文章 (opens new window)</a>，这属于计算机组成的知识。</p><blockquote><p>每个数据库表的行格式都有「变长字段字节数列表」吗？</p></blockquote><p>其实变长字段字节数列表不是必须的。</p><p><strong>当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</strong>，因为没必要，不如去掉以节省空间。</p><p>所以「变长字段长度列表」只出现在数据表有变长字段的时候。</p><ol start=2><li>NULL 值列表</li></ol><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。</p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li></ul><p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code>。</p><p>还是以 t_user 表的这三条记录作为例子：</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/t_test.png alt=img></p><p>接下来，我们看看看看这三条记录的行格式中的 NULL 值列表是怎样存储的。</p><p>先来看<strong>第一条记录</strong>，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/null%E5%80%BC%E5%88%97%E8%A1%A81.png alt=img></p><p>但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是酱紫的：</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null%e5%80%bc%e5%88%97%e8%a1%a82.png alt=img></p><p>所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。</p><p><strong>第三条记录</strong>，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/null%E5%80%BC%E5%88%97%E8%A1%A84.png alt=img></p><p>我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null%e5%80%bc%e5%88%97%e8%a1%a85.png alt=img></p><blockquote><p>每个数据库表的行格式都有「NULL 值列表」吗？</p></blockquote><p>NULL 值列表也不是必须的。</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。</p><p>所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。</p><blockquote><p>「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？</p></blockquote><p>「NULL 值列表」的空间不是固定 1 字节的。</p><p>当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p><ol start=3><li>记录头信息</li></ol><p>记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：</p><ul><li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li><li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul><p><strong>记录的真实数据</strong></p><p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.png alt=img></p><ul><li>row_id</li></ul><p>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p><ul><li>trx_id</li></ul><p>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p><ul><li>roll_pointer</li></ul><p>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</p><h2 id=varcharn-中-n-最大取值为多少>varchar(n) 中 n 最大取值为多少？</h2><p>我们要清楚一点，<strong>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节</strong>。</p><p>也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。</p><p>知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」</p><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。</p><p>要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。</p><p>单字段的情况</p><p>前面我们知道了，一行记录最大只能存储 65535 字节的数据。</p><p>那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下， varchar(n) 中 n 最大取值是 65535 吗？</p><p>不着急说结论，我们先来做个实验验证一下。</p><p>我们定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>TABLE</span> test ( 
</span></span><span style=display:flex><span><span style=color:#ff79c6>`</span>name<span style=color:#ff79c6>`</span> <span style=color:#8be9fd;font-style:italic>VARCHAR</span>(<span style=color:#bd93f9>65535</span>)  <span style=color:#ff79c6>NULL</span>
</span></span><span style=display:flex><span>) ENGINE <span style=color:#ff79c6>=</span> InnoDB <span style=color:#ff79c6>DEFAULT</span> <span style=color:#8be9fd;font-style:italic>CHARACTER</span> <span style=color:#ff79c6>SET</span> <span style=color:#ff79c6>=</span> ascii ROW_FORMAT <span style=color:#ff79c6>=</span> COMPACT;
</span></span></code></pre></div><p>看能不能成功创建一张表：</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/error.png alt=img></p><p>可以看到，创建失败了。</p><p>从报错信息就可以知道<strong>一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead</strong>。</p><p>问题来了，这个 storage overhead 是什么呢？其实就是「变长字段长度列表」和 「NULL 值列表」，也就是说<strong>一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的</strong>。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。</p><p>这是因为我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：</p><ul><li>真实数据</li><li>真实数据占用的字节数</li><li>NULL 标识，如果不允许为NULL，这部分不需要</li></ul><p>「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。</p><p>所以，我们要先知道每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：</p><ul><li>条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；</li><li>条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；</li></ul><p>我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。</p><p><strong>因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」= 1 个「变长字段长度」占用的字节数，也就是 2 字节</strong>。</p><p>因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，<strong>在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532</strong>。</p><p>看看 varchar(65532) 是否可行？</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/65532.png alt=img></p><p>可以看到，创建成功了。说明我们的推论是正确的，在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。</p><p>当然，我上面这个例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n) 最多能存储的数据计算方式就不一样了：</p><ul><li>在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。</li></ul><p>上面所说的只是针对于一个字段的计算方式。</p><p>多字段的情况</p><p><strong>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= 65535</strong>。</p><p>这里举个多字段的情况的例子（感谢@Emoji同学提供的例子）</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%9A%84%E6%83%85%E5%86%B5.png alt=img></p><h2 id=行溢出后mysql-是怎么处理的>行溢出后，MySQL 是怎么处理的？</h2><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p><p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E8%A1%8C%E6%BA%A2%E5%87%BA.png alt=img></p><p>上面这个是 Compact 行格式在发生行溢出后的处理。</p><p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。</p><p>这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png alt=img></p><h1 id=参考>参考：</h1><p><a href=https://xiaolincoding.com/mysql/base/how_select.html#%E6%80%BB%E7%BB%93>https://xiaolincoding.com/mysql/base/how_select.html#%E6%80%BB%E7%BB%93</a>
<a href=https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98>https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98</a>
<a href=https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html>https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html</a></p><hr><ul class=pager><li class=previous><a href=/post/mysql%E5%85%AB%E8%82%A1-%E7%B4%A2%E5%BC%95/ data-toggle=tooltip data-placement=top title=【八股】mysql-索引>&larr;
Previous Post</a></li><li class=next><a href=/post/java%E5%85%AB%E8%82%A1-%E5%9F%BA%E7%A1%80/ data-toggle=tooltip data-placement=top title=【八股】java-基础>Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/mysql%E5%85%AB%E8%82%A1 title=mysql八股>mysql八股</a>
<a href=/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1 title=数学建模>数学建模</a>
<a href=/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB title=经验分享>经验分享</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://liebing.org.cn/>Liebing的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:lizuolin1229@163.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/vx.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/lynnlee1229><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://www.linkedin.com/in/lynn-lee-4a6180237><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://www.instagram.com/lynn_lee_1229><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-instagram fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Lynn's Site"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Lynn's Site 2023<br></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>