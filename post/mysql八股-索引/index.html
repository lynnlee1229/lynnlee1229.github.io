<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Lynn's Site"><meta property="og:type" content="article"><meta property="og:image" content="/img/ram.png"><meta property="twitter:image" content="/img/ram.png"><meta name=title content="【八股】mysql-索引"><meta property="og:title" content="【八股】mysql-索引"><meta property="twitter:title" content="【八股】mysql-索引"><meta name=description content="李柞霖，武汉大学硕士研究生, 开源爱好者 | 这里是 李柞霖 的个人主页"><meta property="og:description" content="李柞霖，武汉大学硕士研究生, 开源爱好者 | 这里是 李柞霖 的个人主页"><meta property="twitter:description" content="李柞霖，武汉大学硕士研究生, 开源爱好者 | 这里是 李柞霖 的个人主页"><meta property="twitter:card" content="summary"><meta name=keyword content="李柞霖, Li Zuolin, Lynn Lee, 李柞霖的主页"><link rel="shortcut icon" href=/image/favicon.ico><title>【八股】mysql-索引 | 李柞霖的博客</title><link rel=canonical href=/post/mysql%E5%85%AB%E8%82%A1-%E7%B4%A2%E5%BC%95/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link href=https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css rel=stylesheet type=text/css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>Lynn's Site</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/research>research</a></li><li><a href=/categories/technology>technology</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/ram.png)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/mysql%E5%85%AB%E8%82%A1 title=mysql八股>mysql八股</a></div><h1>【八股】mysql-索引</h1><h2 class=subheading></h2><span class=meta>Posted by
Lynn
on
Friday, May 12, 2023</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=什么是索引>什么是索引</h1><p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p><p>所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 存储引擎有 MyISAM 、InnoDB、Memory，其中 InnoDB 是在 MySQL 5.5 之后成为默认的存储引擎。</p><p>下图是 MySQL 的结构图，索引和数据就是位于存储引擎中：</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/1623727651911_20170928110355446.png alt=img></p><p><strong>索引的优点</strong></p><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><p><strong>索引的缺点</strong></p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li><li>空间方面：索引需要占物理空间。</li></ul><h1 id=索引的分类>索引的分类</h1><p>我们可以按照四个角度来分类索引。</p><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><h2 id=按数据结构分>按数据结构分</h2><p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。</p><p>每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio-20230512211308312.png alt=img></p><p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次</strong></p><h3 id=为什么innodb选择btree作为索引的数据结构>为什么InnoDB选择B+tree作为索引的数据结构</h3><p>详见：「<a href=https://mp.weixin.qq.com/s/w1ZFOug8-Sa7ThtMnlaUtQ>B+树详解</a>」。</p><p><em><strong>1、B+Tree vs B Tree</strong></em></p><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。</p><p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p><p><em><strong>2、B+Tree vs 二叉树</strong></em></p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。</p><p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</p><p><em><strong>3、B+Tree vs Hash</strong></em></p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因</p><h2 id=按物理存储分>按物理存储分</h2><p>从物理存储的角度来看，索引分为<strong>聚簇索引</strong>（主键索引）、<strong>二级索引</strong>（辅助索引）。</p><p>这两个区别在前面也提到了：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p><h2 id=按字段特性分>按字段特性分</h2><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><ul><li>主键索引</li></ul><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，<strong>索引列的值不允许有空值</strong>。</p><p>在创建表时，创建主键索引的方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>TABLE</span> <span style=color:#ff79c6>table_name</span>  (
</span></span><span style=display:flex><span>  ....
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>PRIMARY</span> <span style=color:#ff79c6>KEY</span> (index_column_1) <span style=color:#ff79c6>USING</span> BTREE
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><ul><li>唯一索引</li></ul><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p>在创建表时，创建唯一索引的方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>TABLE</span> <span style=color:#ff79c6>table_name</span>  (
</span></span><span style=display:flex><span>  ....
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>UNIQUE</span> <span style=color:#ff79c6>KEY</span>(index_column_1,index_column_2,...) 
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>建表后，如果要创建唯一索引，可以使用这面这条命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>UNIQUE</span> <span style=color:#ff79c6>INDEX</span> index_name
</span></span><span style=display:flex><span><span style=color:#ff79c6>ON</span> <span style=color:#ff79c6>table_name</span>(index_column_1,index_column_2,...); 
</span></span></code></pre></div><ul><li>普通索引</li></ul><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><p>在创建表时，创建普通索引的方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>TABLE</span> <span style=color:#ff79c6>table_name</span>  (
</span></span><span style=display:flex><span>  ....
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>INDEX</span>(index_column_1,index_column_2,...) 
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>建表后，如果要创建普通索引，可以使用这面这条命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>INDEX</span> index_name
</span></span><span style=display:flex><span><span style=color:#ff79c6>ON</span> <span style=color:#ff79c6>table_name</span>(index_column_1,index_column_2,...); 
</span></span></code></pre></div><ul><li>前缀索引</li></ul><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><p>在创建表时，创建前缀索引的方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>TABLE</span> <span style=color:#ff79c6>table_name</span>(
</span></span><span style=display:flex><span>    column_list,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>INDEX</span>(<span style=color:#ff79c6>column_name</span>(<span style=color:#ff79c6>length</span>))
</span></span><span style=display:flex><span>); 
</span></span></code></pre></div><p>建表后，如果要创建前缀索引，可以使用这面这条命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>INDEX</span> index_name
</span></span><span style=display:flex><span><span style=color:#ff79c6>ON</span> <span style=color:#ff79c6>table_name</span>(<span style=color:#ff79c6>column_name</span>(<span style=color:#ff79c6>length</span>)); 
</span></span></code></pre></div><h2 id=按字段个数分>按字段个数分</h2><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引；</li><li>建立在多列上的索引称为联合索引；</li></ul><h3 id=联合索引>联合索引</h3><p>通过将多个字段组合成一个索引，该索引就被称为联合索引</p><p>比如，将商品表中的 product_no 和 name 字段组合成联合索引<code>(product_no, name)</code>，创建联合索引的方式如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>CREATE</span> <span style=color:#ff79c6>INDEX</span> index_product_no_name <span style=color:#ff79c6>ON</span> product(product_no, name);
</span></span></code></pre></div><p>联合索引<code>(product_no, name)</code> 的 B+Tree 示意图如下（图中叶子节点之间画了单向链表，但是实际上是双向链表）。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio-20230512214343106-20230512214447616.png alt=联合索引></p><p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</p><p>也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</p><p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b=2；</li><li>where c=3；</li><li>where b=2 and c=3；</li></ul><p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p><h4 id=联合索引范围查询>联合索引范围查询</h4><p>联合索引有一些特殊情况，可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。这种特殊情况就发生在范围查询。<strong>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。</strong></p><p>范围查询有很多种，那到底是哪些范围查询会导致联合索引的最左匹配原则会停止匹配呢？</p><p>接下来，举例几个范围查例子。</p><blockquote><p>Q1: <code>select * from t_table where a > 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a > 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。</p><p><strong>但是在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的</strong>。比如前面图的联合索引的 B+ Tree 里，下面这三条记录的 a 字段的值都符合 a > 1 查询条件，而 b 字段的值是无序的：</p><ul><li>a 字段值为 5 的记录，该记录的 b 字段值为 8；</li><li>a 字段值为 6 的记录，该记录的 b 字段值为 10；</li><li>a 字段值为 7 的记录，该记录的 b 字段值为 5；</li></ul><p>因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量（b 字段无法利用联合索引进行索引查询的意思）。</p><p>所以在执行 Q1 这条查询语句的时候，对应的扫描区间是 (2, + ∞)，形成该扫描区间的边界条件是 a > 1，与 b = 2 无关。</p><p>因此，<strong>Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</p><p>我们也可以在执行计划中的 key_len 知道这一点，在使用联合索引进行查询的时候，通过 <strong>key_len 我们可以知道优化器具体使用了多少个字段的搜索条件来形成扫描区间的边界条件</strong>。</p><p>举例个例子 ，a 和 b 都是 int 类型且不为 NULL 的字段，那么 Q1 这条查询语句执行计划如下，可以看到 key_len 为 4 字节（如果字段允许为 NULL，就在字段类型占用的字节数上加 1，也就是 5 字节），说明只有 a 字段用到了联合索引进行索引查询，而且可以看到，即使 b 字段没用到联合索引，key 为 idx_a_b，说明 Q1 查询语句使用了 idx_a_b 联合索引。</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%e7%b4%a2%e5%bc%95/q1.png alt=img></p><p>通过 Q1 查询语句我们可以知道，a 字段使用了 > 进行范围查询，联合索引的最左匹配原则在遇到 a 字段的范围查询（ >）后就停止匹配了，因此 b 字段并没有使用到联合索引。</p><blockquote><p>Q2: <code>select * from t_table where a >= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>Q2 和 Q1 的查询语句很像，唯一的区别就是 a 字段的查询条件「大于等于」。</p><p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 >= 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 >= 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a>= 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。</p><p>虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，<strong>但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的</strong>，于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。</p><p>所以，<strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><p>我们也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 a 和 b 字段都用到了联合索引进行索引查询。</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/q2.png alt=img></p><p>通过 Q2 查询语句我们可以知道，虽然 a 字段使用了 >= 进行范围查询，但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（ >=）后就停止匹配了，b 字段还是可以用到了联合索引的。</p><blockquote><p>Q3: <code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>Q3 查询条件中 <code>a BETWEEN 2 AND 8</code> 的意思是查询 a 字段的值在 2 和 8 之间的记录。不同的数据库对 BETWEEN &mldr; AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and =&lt;。而有的数据库则不包含 value1 和 value2 边界值（类似于 > and &lt;）。</p><p>这里我们只讨论 MySQL。由于 MySQL 的 BETWEEN 包含 value1 和 value2 边界值，所以类似于 Q2 查询语句，因此 <strong>Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><p>我们也可以在执行计划中的 key_len 知道这一点。执行计划如下，可以看到 key_len 为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 a 和 b 字段都用到了联合索引进行索引查询。</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%e7%b4%a2%e5%bc%95/q3.png alt=img></p><p>通过 Q3 查询语句我们可以知道，虽然 a 字段使用了 BETWEEN 进行范围查询，但是联合索引的最左匹配原则并没有在遇到 a 字段的范围查询（ BETWEEN）后就停止匹配了，b 字段还是可以用到了联合索引的。</p><blockquote><p>Q4: <code>SELECT * FROM t_user WHERE name like 'j%' and age = 22</code>，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为 ‘j’ 为止。</p><p>所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是[&lsquo;j&rsquo;,&lsquo;k&rsquo;)。注意， j 是闭区间。如下图：</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%e7%b4%a2%e5%bc%95/q4-1.drawio.png alt=img></p><p>虽然在符合前缀为 ‘j’ 的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，<strong>但是对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的</strong>（因为对于联合索引，是先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序）。</p><p>于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 name 字段值为 ‘j’ 时，可以通过 age = 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 <code>name = 'j' and age = 22</code> 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描 。如下图的右边：</p><p><img src=https://raw.githubusercontent.com/lynnlee1229/PictureBed/main/q4-2.drawio-20230512221354816.png alt=img></p><p>所以，<strong>Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><p>我们也可以在执行计划中的 key_len 知道这一点。本次例子中：</p><ul><li>name 字段的类型是 varchar(30) 且不为 NULL，数据库表使用了 utf8mb4 字符集，一个字符集为 utf8mb4 的字符是 4 个字节，因此 name 字段的实际数据最多占用的存储空间长度是 120 字节（30 x 4），然后因为 name 是变长类型的字段，需要再加 2 字节（用于存储该字段实际数据的长度值），也就是 name 的 key_len 为 122。</li><li>age 字段的类型是 int 且不为 NULL，key_len 为 4。</li></ul><p>TIP</p><p>可能有的同学对于「因为 name 是变长类型的字段，需要再加 2 字节」这句话有疑问。之前这篇<a href=https://xiaolincoding.com/mysql/base/row_format.html>文章 (opens new window)</a>说「如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示变长字段的长度」，而这里为什么是 2 字节？</p><p>key_len 的显示比较特殊，行格式是由 innodb存 储引擎实现的，而执行计划是在server 层生成的，所以它不会去问 innodb 存储引擎可变字段的长度占用多少字节，而是不管三七二十一都使用 2 字节表示可变字段的长度。</p><p>毕竟 <strong>key_len 的目的只是为了告诉你索引查询中用了哪些索引字段，而不是为了准确告诉这个字段占用多少字节空间</strong>。</p><p>Q4 查询语句的执行计划如下，可以看到 key_len 为 126 字节，name 的 key_len 为 122，age 的 key_len 为 4，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是 name 和 age 字段都用到了联合索引进行索引查询。</p><p><img src=https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%e7%b4%a2%e5%bc%95/q4-%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92.png alt=img></p><p>通过 Q4 查询语句我们可以知道，虽然 name 字段使用了 like 前缀匹配进行范围查询，但是联合索引的最左匹配原则并没有在遇到 name 字段的范围查询（ like &lsquo;j%&rsquo;）后就停止匹配了，age 字段还是可以用到了联合索引的。</p><p>综上所示，<strong>联合索引的最左匹配原则，在遇到范围查询（如 >、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了</strong>。</p><h4 id=索引下推>索引下推</h4><p>对于联合索引（a, b），在执行 <code>select * from table where a > 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化。</p><h4 id=索引区分度>索引区分度</h4><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><p>区分度就是某个字段 column 不同值的个数「除以」表的总行数，比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 <strong>MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是"30%"）很高的时候，它一般会忽略索引，进行全表扫描</strong>。</p><h4 id=联合索引排序>联合索引排序</h4><p>针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#ff79c6>select</span> <span style=color:#ff79c6>*</span> <span style=color:#ff79c6>from</span> <span style=color:#ff79c6>order</span> <span style=color:#ff79c6>where</span> status <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span> <span style=color:#ff79c6>order</span> <span style=color:#ff79c6>by</span> create_time <span style=color:#ff79c6>asc</span>
</span></span></code></pre></div><p>有的同学会认为，单独给 status 建立一个索引就可以了。</p><p>但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</p><p>因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。</p><p>所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率</p><h1 id=参考>参考：</h1><p><a href=https://xiaolincoding.com/mysql/base/how_select.html#%E6%80%BB%E7%BB%93>https://xiaolincoding.com/mysql/base/how_select.html#%E6%80%BB%E7%BB%93</a>
<a href=https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98>https://www.javalearn.cn/#/doc/MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98</a>
<a href=https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html>https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html</a></p><hr><ul class=pager><li class=previous><a href=/post/%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAjupyter-notebook%E6%96%87%E4%BB%B6/ data-toggle=tooltip data-placement=top title="【经验分享】合并多个jupyter notebook文件">&larr;
Previous Post</a></li><li class=next><a href=/post/mysql%E5%85%AB%E8%82%A1-%E5%9F%BA%E7%A1%80/ data-toggle=tooltip data-placement=top title=【八股】mysql-基础>Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/mysql%E5%85%AB%E8%82%A1 title=mysql八股>mysql八股</a>
<a href=/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1 title=数学建模>数学建模</a>
<a href=/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB title=经验分享>经验分享</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://liebing.org.cn/>Liebing的博客</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:lizuolin1229@163.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/vx.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/lynnlee1229><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://www.linkedin.com/in/lynn-lee-4a6180237><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://www.instagram.com/lynn_lee_1229><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-instagram fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Lynn's Site"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Lynn's Site 2023<br></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>